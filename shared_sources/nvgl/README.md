# OpenGL Api Helpers

Non-exhaustive list of utilities provided in the `nvgl` directory

Table of Contents:
- [appwindowprofiler_gl.hpp:](#appwindowprofiler_glhpp)
  - class [nvgl::AppWindowProfilerGL](#class-nvglappwindowprofilergl)
- [base_gl.hpp:](#base_glhpp)
- [contextwindow_gl.hpp:](#contextwindow_glhpp)
  - class [nvgl::ContextWindow](#class-nvglcontextwindow)
- [error_gl.hpp:](#error_glhpp)
  - class [nvgl::CheckBufferResidency](#class-nvglcheckbufferresidency)
- [extensions_gl.hpp:](#extensions_glhpp)
- [glsltypes_gl.hpp:](#glsltypes_glhpp)
- [profiler_gl.hpp:](#profiler_glhpp)
  - class [nvgl::ProfilerGL](#class-nvglprofilergl)
- [programmanager_gl.hpp:](#programmanager_glhpp)
  - class [nvgl::ProgramManager](#class-nvglprogrammanager)

_____

## appwindowprofiler_gl.hpp

### class **nvgl::AppWindowProfilerGL**

**AppWindowProfilerGL** derives from **nvh::AppWindowProfiler**
and overrides the context and swapbuffer functions.

To influence the context creation modify
`m_contextInfo` prior running AppWindowProfiler::run,
which triggers window, and context creation etc.

The class comes with a **nvgl::ProfilerGL** instance that references the 
AppWindowProfiler::m_profiler's data.

## base_gl.hpp

### struct **nvgl::BufferBinding**
Wraps buffer, offset, size, gpu address


### struct **nvgl::TextureBuffer**
A `GL_TEXTURE_BUFFER` that references the provided buffer.
Wraps texture and bindless texture handle.


### struct **nvgl::Buffer**
Wraps buffer as well as optionally creates a `GL_TEXTURE_BUFFER` if
a non-null `format` is provided. If bindless is available it will
also create bindless handles for all resources and make them resident.

If the `flags` contain `GL_MAP_PERSISTENT_BIT` it will also map
the buffer and keep the host pointer.


### nvgl resource functions

Functions that wrap glCreate/glDelete and operate on `GLuint& obj`.
The "new" functions delete the existing object if non-null and create a new one.
The "delete" functions delete non-null objects.

* newBuffer / deleteBuffer
* newTextureView
* newTexture / deleteTexture
* newFramebuffer / deleteFramebuffer
* newSampler / deleteSampler
* newQuery / deleteQuery
* newVertexArray / deleteVertexArray

~~~ C++
// typical use-case
FrameBuffer::resize(int with, int height){
  newFramebuffer(m_fbo);
  newTexture(m_color, GL_TEXTURE_2D);
  newTexture(m_depthStencil, GL_TEXTURE_2D);
  glTextureStorage2D(m_color, ...)
  glTextureStorage2D(m_depthStencil, ...)
  glNamedFramebufferTexture(m_fbo, GL_COLOR_ATTACHMENT0,        m_color, 0);
  glNamedFramebufferTexture(m_fbo, GL_DEPTH_STENCIL_ATTACHMENT, m_depthStencil, 0);
}
~~~

## contextwindow_gl.hpp

### struct **nvgl::ContextWindowCreateInfo**

Set up the context properties for a OpenGL **ContextWindow**.
e.g. version, core/compatibiltiy etc.


### class **nvgl::ContextWindow**

Sets up an OpenGL context from a provided `GLFWwindow`.
Makes use of `glDebugMessageCallback` to hook up an error callback
and loads all extensions provided by `extensions_gl.hpp`

## error_gl.hpp

### functions in nvgl

Several utility functions that aid debugging. Check if all bindings
are cleared, framebuffer complete etc.


### template class **nvgl::CheckBufferContent**
Utility wrapper to downlad buffer data into a temp vector for debugging


### class **nvgl::CheckBufferResidency**
Utility class to test if a certain gpu address is coming from
a resident buffer. Register the address of buffers in advance.

## extensions_gl.hpp

### OpenGL Extension loader

Provides a subset of OpenGL Extensions generated by `extensions_gl.lua`.
The framework uses a sanitized OpenGL header that is mostly core functionality.
`GL/glsubset.h` is generated using a whitelist by the lua script
from `GL/glcustom.h` (which is mostly based on `glcorearb.h` with some
additional extensions and features)

## glsltypes_gl.hpp

### type definitions for nvgl and nvmath
Sets up vector, matrix etc. types available in GLSL

## profiler_gl.hpp

### class **nvgl::ProfilerGL**

**ProfilerGL** extends **Profiler** and uses `glQueryCounter(... GL_TIMESTAMP)`
to compute the GPU time of a section.
`glPushDebugGroup` and `glPopDebugGroup` are used within each timed
section, so that the section names can show up in NSightGraphics,
renderdoc or comparable tools.

## programmanager_gl.hpp

### class **nvgl::ProgramManager**

The **ProgramManager** manages OpenGL programs generated from shader files (GLSL)

Using **ShaderFileManager** it will find the files and resolve #include for GLSL.
You must add include directories to the base-class for this.

It also comes with some convenience functions to reload shaders etc.
That is why we pass out the **ProgramID** rather than a GLuint directly.

Example:

``` c++
ProgramManager mgr;

// derived from ShaderFileManager
mgr.addDirectory("/shaders/")

// injected after #version directive
mgr.m_prepend = "#define USE_NOISE 1\n";

id = mgr.createProgram({{GL_VERTEX_SHADER, "object.vert.glsl"},{GL_FRAGMENT_SHADER, "object.frag.glsl"}}):

glUseProgram(mgr.get(id));
```




_____
auto-generated by `docgen.lua`
